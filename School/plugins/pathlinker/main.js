/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@capacitor/core/dist/index.js
var ExceptionCode, CapacitorException, getPlatformId, createCapacitor, initCapacitorGlobal, Capacitor, registerPlugin, WebPlugin, encode, decode, CapacitorCookiesPluginWeb, CapacitorCookies, readBlobAsBase64, normalizeHttpHeaders, buildUrlParams, buildRequestInit, CapacitorHttpPluginWeb, CapacitorHttp;
var init_dist = __esm({
  "node_modules/@capacitor/core/dist/index.js"() {
    (function(ExceptionCode2) {
      ExceptionCode2["Unimplemented"] = "UNIMPLEMENTED";
      ExceptionCode2["Unavailable"] = "UNAVAILABLE";
    })(ExceptionCode || (ExceptionCode = {}));
    CapacitorException = class extends Error {
      constructor(message, code, data) {
        super(message);
        this.message = message;
        this.code = code;
        this.data = data;
      }
    };
    getPlatformId = (win) => {
      var _a, _b;
      if (win === null || win === void 0 ? void 0 : win.androidBridge) {
        return "android";
      } else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
        return "ios";
      } else {
        return "web";
      }
    };
    createCapacitor = (win) => {
      const capCustomPlatform = win.CapacitorCustomPlatform || null;
      const cap = win.Capacitor || {};
      const Plugins = cap.Plugins = cap.Plugins || {};
      const getPlatform = () => {
        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
      };
      const isNativePlatform = () => getPlatform() !== "web";
      const isPluginAvailable = (pluginName) => {
        const plugin = registeredPlugins.get(pluginName);
        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
          return true;
        }
        if (getPluginHeader(pluginName)) {
          return true;
        }
        return false;
      };
      const getPluginHeader = (pluginName) => {
        var _a;
        return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName);
      };
      const handleError = (err) => win.console.error(err);
      const registeredPlugins = /* @__PURE__ */ new Map();
      const registerPlugin2 = (pluginName, jsImplementations = {}) => {
        const registeredPlugin = registeredPlugins.get(pluginName);
        if (registeredPlugin) {
          console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
          return registeredPlugin.proxy;
        }
        const platform = getPlatform();
        const pluginHeader = getPluginHeader(pluginName);
        let jsImplementation;
        const loadPluginImplementation = async () => {
          if (!jsImplementation && platform in jsImplementations) {
            jsImplementation = typeof jsImplementations[platform] === "function" ? jsImplementation = await jsImplementations[platform]() : jsImplementation = jsImplementations[platform];
          } else if (capCustomPlatform !== null && !jsImplementation && "web" in jsImplementations) {
            jsImplementation = typeof jsImplementations["web"] === "function" ? jsImplementation = await jsImplementations["web"]() : jsImplementation = jsImplementations["web"];
          }
          return jsImplementation;
        };
        const createPluginMethod = (impl, prop) => {
          var _a, _b;
          if (pluginHeader) {
            const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);
            if (methodHeader) {
              if (methodHeader.rtype === "promise") {
                return (options) => cap.nativePromise(pluginName, prop.toString(), options);
              } else {
                return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
              }
            } else if (impl) {
              return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);
            }
          } else if (impl) {
            return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
          } else {
            throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);
          }
        };
        const createPluginMethodWrapper = (prop) => {
          let remove;
          const wrapper = (...args) => {
            const p = loadPluginImplementation().then((impl) => {
              const fn = createPluginMethod(impl, prop);
              if (fn) {
                const p2 = fn(...args);
                remove = p2 === null || p2 === void 0 ? void 0 : p2.remove;
                return p2;
              } else {
                throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode.Unimplemented);
              }
            });
            if (prop === "addListener") {
              p.remove = async () => remove();
            }
            return p;
          };
          wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
          Object.defineProperty(wrapper, "name", {
            value: prop,
            writable: false,
            configurable: false
          });
          return wrapper;
        };
        const addListener = createPluginMethodWrapper("addListener");
        const removeListener = createPluginMethodWrapper("removeListener");
        const addListenerNative = (eventName, callback) => {
          const call = addListener({ eventName }, callback);
          const remove = async () => {
            const callbackId = await call;
            removeListener({
              eventName,
              callbackId
            }, callback);
          };
          const p = new Promise((resolve2) => call.then(() => resolve2({ remove })));
          p.remove = async () => {
            console.warn(`Using addListener() without 'await' is deprecated.`);
            await remove();
          };
          return p;
        };
        const proxy = new Proxy({}, {
          get(_, prop) {
            switch (prop) {
              case "$$typeof":
                return void 0;
              case "toJSON":
                return () => ({});
              case "addListener":
                return pluginHeader ? addListenerNative : addListener;
              case "removeListener":
                return removeListener;
              default:
                return createPluginMethodWrapper(prop);
            }
          }
        });
        Plugins[pluginName] = proxy;
        registeredPlugins.set(pluginName, {
          name: pluginName,
          proxy,
          platforms: /* @__PURE__ */ new Set([...Object.keys(jsImplementations), ...pluginHeader ? [platform] : []])
        });
        return proxy;
      };
      if (!cap.convertFileSrc) {
        cap.convertFileSrc = (filePath) => filePath;
      }
      cap.getPlatform = getPlatform;
      cap.handleError = handleError;
      cap.isNativePlatform = isNativePlatform;
      cap.isPluginAvailable = isPluginAvailable;
      cap.registerPlugin = registerPlugin2;
      cap.Exception = CapacitorException;
      cap.DEBUG = !!cap.DEBUG;
      cap.isLoggingEnabled = !!cap.isLoggingEnabled;
      return cap;
    };
    initCapacitorGlobal = (win) => win.Capacitor = createCapacitor(win);
    Capacitor = /* @__PURE__ */ initCapacitorGlobal(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    registerPlugin = Capacitor.registerPlugin;
    WebPlugin = class {
      constructor() {
        this.listeners = {};
        this.retainedEventArguments = {};
        this.windowListeners = {};
      }
      addListener(eventName, listenerFunc) {
        let firstListener = false;
        const listeners = this.listeners[eventName];
        if (!listeners) {
          this.listeners[eventName] = [];
          firstListener = true;
        }
        this.listeners[eventName].push(listenerFunc);
        const windowListener = this.windowListeners[eventName];
        if (windowListener && !windowListener.registered) {
          this.addWindowListener(windowListener);
        }
        if (firstListener) {
          this.sendRetainedArgumentsForEvent(eventName);
        }
        const remove = async () => this.removeListener(eventName, listenerFunc);
        const p = Promise.resolve({ remove });
        return p;
      }
      async removeAllListeners() {
        this.listeners = {};
        for (const listener in this.windowListeners) {
          this.removeWindowListener(this.windowListeners[listener]);
        }
        this.windowListeners = {};
      }
      notifyListeners(eventName, data, retainUntilConsumed) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
          if (retainUntilConsumed) {
            let args = this.retainedEventArguments[eventName];
            if (!args) {
              args = [];
            }
            args.push(data);
            this.retainedEventArguments[eventName] = args;
          }
          return;
        }
        listeners.forEach((listener) => listener(data));
      }
      hasListeners(eventName) {
        var _a;
        return !!((_a = this.listeners[eventName]) === null || _a === void 0 ? void 0 : _a.length);
      }
      registerWindowListener(windowEventName, pluginEventName) {
        this.windowListeners[pluginEventName] = {
          registered: false,
          windowEventName,
          pluginEventName,
          handler: (event) => {
            this.notifyListeners(pluginEventName, event);
          }
        };
      }
      unimplemented(msg = "not implemented") {
        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
      }
      unavailable(msg = "not available") {
        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
      }
      async removeListener(eventName, listenerFunc) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
          return;
        }
        const index = listeners.indexOf(listenerFunc);
        this.listeners[eventName].splice(index, 1);
        if (!this.listeners[eventName].length) {
          this.removeWindowListener(this.windowListeners[eventName]);
        }
      }
      addWindowListener(handle) {
        window.addEventListener(handle.windowEventName, handle.handler);
        handle.registered = true;
      }
      removeWindowListener(handle) {
        if (!handle) {
          return;
        }
        window.removeEventListener(handle.windowEventName, handle.handler);
        handle.registered = false;
      }
      sendRetainedArgumentsForEvent(eventName) {
        const args = this.retainedEventArguments[eventName];
        if (!args) {
          return;
        }
        delete this.retainedEventArguments[eventName];
        args.forEach((arg) => {
          this.notifyListeners(eventName, arg);
        });
      }
    };
    encode = (str) => encodeURIComponent(str).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
    CapacitorCookiesPluginWeb = class extends WebPlugin {
      async getCookies() {
        const cookies = document.cookie;
        const cookieMap = {};
        cookies.split(";").forEach((cookie) => {
          if (cookie.length <= 0)
            return;
          let [key, value] = cookie.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
          key = decode(key).trim();
          value = decode(value).trim();
          cookieMap[key] = value;
        });
        return cookieMap;
      }
      async setCookie(options) {
        try {
          const encodedKey = encode(options.key);
          const encodedValue = encode(options.value);
          const expires = `; expires=${(options.expires || "").replace("expires=", "")}`;
          const path2 = (options.path || "/").replace("path=", "");
          const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : "";
          document.cookie = `${encodedKey}=${encodedValue || ""}${expires}; path=${path2}; ${domain};`;
        } catch (error) {
          return Promise.reject(error);
        }
      }
      async deleteCookie(options) {
        try {
          document.cookie = `${options.key}=; Max-Age=0`;
        } catch (error) {
          return Promise.reject(error);
        }
      }
      async clearCookies() {
        try {
          const cookies = document.cookie.split(";") || [];
          for (const cookie of cookies) {
            document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);
          }
        } catch (error) {
          return Promise.reject(error);
        }
      }
      async clearAllCookies() {
        try {
          await this.clearCookies();
        } catch (error) {
          return Promise.reject(error);
        }
      }
    };
    CapacitorCookies = registerPlugin("CapacitorCookies", {
      web: () => new CapacitorCookiesPluginWeb()
    });
    readBlobAsBase64 = async (blob) => new Promise((resolve2, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64String = reader.result;
        resolve2(base64String.indexOf(",") >= 0 ? base64String.split(",")[1] : base64String);
      };
      reader.onerror = (error) => reject(error);
      reader.readAsDataURL(blob);
    });
    normalizeHttpHeaders = (headers = {}) => {
      const originalKeys = Object.keys(headers);
      const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());
      const normalized = loweredKeys.reduce((acc, key, index) => {
        acc[key] = headers[originalKeys[index]];
        return acc;
      }, {});
      return normalized;
    };
    buildUrlParams = (params, shouldEncode = true) => {
      if (!params)
        return null;
      const output = Object.entries(params).reduce((accumulator, entry) => {
        const [key, value] = entry;
        let encodedValue;
        let item;
        if (Array.isArray(value)) {
          item = "";
          value.forEach((str) => {
            encodedValue = shouldEncode ? encodeURIComponent(str) : str;
            item += `${key}=${encodedValue}&`;
          });
          item.slice(0, -1);
        } else {
          encodedValue = shouldEncode ? encodeURIComponent(value) : value;
          item = `${key}=${encodedValue}`;
        }
        return `${accumulator}&${item}`;
      }, "");
      return output.substr(1);
    };
    buildRequestInit = (options, extra = {}) => {
      const output = Object.assign({ method: options.method || "GET", headers: options.headers }, extra);
      const headers = normalizeHttpHeaders(options.headers);
      const type = headers["content-type"] || "";
      if (typeof options.data === "string") {
        output.body = options.data;
      } else if (type.includes("application/x-www-form-urlencoded")) {
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(options.data || {})) {
          params.set(key, value);
        }
        output.body = params.toString();
      } else if (type.includes("multipart/form-data") || options.data instanceof FormData) {
        const form = new FormData();
        if (options.data instanceof FormData) {
          options.data.forEach((value, key) => {
            form.append(key, value);
          });
        } else {
          for (const key of Object.keys(options.data)) {
            form.append(key, options.data[key]);
          }
        }
        output.body = form;
        const headers2 = new Headers(output.headers);
        headers2.delete("content-type");
        output.headers = headers2;
      } else if (type.includes("application/json") || typeof options.data === "object") {
        output.body = JSON.stringify(options.data);
      }
      return output;
    };
    CapacitorHttpPluginWeb = class extends WebPlugin {
      /**
       * Perform an Http request given a set of options
       * @param options Options to build the HTTP request
       */
      async request(options) {
        const requestInit = buildRequestInit(options, options.webFetchExtra);
        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
        const url = urlParams ? `${options.url}?${urlParams}` : options.url;
        const response = await fetch(url, requestInit);
        const contentType = response.headers.get("content-type") || "";
        let { responseType = "text" } = response.ok ? options : {};
        if (contentType.includes("application/json")) {
          responseType = "json";
        }
        let data;
        let blob;
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            blob = await response.blob();
            data = await readBlobAsBase64(blob);
            break;
          case "json":
            data = await response.json();
            break;
          case "document":
          case "text":
          default:
            data = await response.text();
        }
        const headers = {};
        response.headers.forEach((value, key) => {
          headers[key] = value;
        });
        return {
          data,
          headers,
          status: response.status,
          url: response.url
        };
      }
      /**
       * Perform an Http GET request given a set of options
       * @param options Options to build the HTTP request
       */
      async get(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: "GET" }));
      }
      /**
       * Perform an Http POST request given a set of options
       * @param options Options to build the HTTP request
       */
      async post(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: "POST" }));
      }
      /**
       * Perform an Http PUT request given a set of options
       * @param options Options to build the HTTP request
       */
      async put(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: "PUT" }));
      }
      /**
       * Perform an Http PATCH request given a set of options
       * @param options Options to build the HTTP request
       */
      async patch(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: "PATCH" }));
      }
      /**
       * Perform an Http DELETE request given a set of options
       * @param options Options to build the HTTP request
       */
      async delete(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: "DELETE" }));
      }
    };
    CapacitorHttp = registerPlugin("CapacitorHttp", {
      web: () => new CapacitorHttpPluginWeb()
    });
  }
});

// node_modules/@capacitor/filesystem/dist/esm/definitions.js
var Directory, Encoding;
var init_definitions = __esm({
  "node_modules/@capacitor/filesystem/dist/esm/definitions.js"() {
    (function(Directory2) {
      Directory2["Documents"] = "DOCUMENTS";
      Directory2["Data"] = "DATA";
      Directory2["Library"] = "LIBRARY";
      Directory2["Cache"] = "CACHE";
      Directory2["External"] = "EXTERNAL";
      Directory2["ExternalStorage"] = "EXTERNAL_STORAGE";
      Directory2["ExternalCache"] = "EXTERNAL_CACHE";
      Directory2["LibraryNoCloud"] = "LIBRARY_NO_CLOUD";
      Directory2["Temporary"] = "TEMPORARY";
    })(Directory || (Directory = {}));
    (function(Encoding2) {
      Encoding2["UTF8"] = "utf8";
      Encoding2["ASCII"] = "ascii";
      Encoding2["UTF16"] = "utf16";
    })(Encoding || (Encoding = {}));
  }
});

// node_modules/@capacitor/filesystem/dist/esm/web.js
var web_exports = {};
__export(web_exports, {
  FilesystemWeb: () => FilesystemWeb
});
function resolve(path2) {
  const posix = path2.split("/").filter((item) => item !== ".");
  const newPosix = [];
  posix.forEach((item) => {
    if (item === ".." && newPosix.length > 0 && newPosix[newPosix.length - 1] !== "..") {
      newPosix.pop();
    } else {
      newPosix.push(item);
    }
  });
  return newPosix.join("/");
}
function isPathParent(parent, children) {
  parent = resolve(parent);
  children = resolve(children);
  const pathsA = parent.split("/");
  const pathsB = children.split("/");
  return parent !== children && pathsA.every((value, index) => value === pathsB[index]);
}
var FilesystemWeb;
var init_web = __esm({
  "node_modules/@capacitor/filesystem/dist/esm/web.js"() {
    init_dist();
    init_definitions();
    FilesystemWeb = class extends WebPlugin {
      constructor() {
        super(...arguments);
        this.DB_VERSION = 1;
        this.DB_NAME = "Disc";
        this._writeCmds = ["add", "put", "delete"];
        this.downloadFile = async (options) => {
          var _a, _b;
          const requestInit = buildRequestInit(options, options.webFetchExtra);
          const response = await fetch(options.url, requestInit);
          let blob;
          if (!options.progress)
            blob = await response.blob();
          else if (!(response === null || response === void 0 ? void 0 : response.body))
            blob = new Blob();
          else {
            const reader = response.body.getReader();
            let bytes = 0;
            const chunks = [];
            const contentType = response.headers.get("content-type");
            const contentLength = parseInt(response.headers.get("content-length") || "0", 10);
            while (true) {
              const { done, value } = await reader.read();
              if (done)
                break;
              chunks.push(value);
              bytes += (value === null || value === void 0 ? void 0 : value.length) || 0;
              const status = {
                url: options.url,
                bytes,
                contentLength
              };
              this.notifyListeners("progress", status);
            }
            const allChunks = new Uint8Array(bytes);
            let position = 0;
            for (const chunk of chunks) {
              if (typeof chunk === "undefined")
                continue;
              allChunks.set(chunk, position);
              position += chunk.length;
            }
            blob = new Blob([allChunks.buffer], { type: contentType || void 0 });
          }
          const result = await this.writeFile({
            path: options.path,
            directory: (_a = options.directory) !== null && _a !== void 0 ? _a : void 0,
            recursive: (_b = options.recursive) !== null && _b !== void 0 ? _b : false,
            data: blob
          });
          return { path: result.uri, blob };
        };
      }
      readFileInChunks(_options, _callback) {
        throw this.unavailable("Method not implemented.");
      }
      async initDb() {
        if (this._db !== void 0) {
          return this._db;
        }
        if (!("indexedDB" in window)) {
          throw this.unavailable("This browser doesn't support IndexedDB");
        }
        return new Promise((resolve2, reject) => {
          const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);
          request.onupgradeneeded = FilesystemWeb.doUpgrade;
          request.onsuccess = () => {
            this._db = request.result;
            resolve2(request.result);
          };
          request.onerror = () => reject(request.error);
          request.onblocked = () => {
            console.warn("db blocked");
          };
        });
      }
      static doUpgrade(event) {
        const eventTarget = event.target;
        const db = eventTarget.result;
        switch (event.oldVersion) {
          case 0:
          case 1:
          default: {
            if (db.objectStoreNames.contains("FileStorage")) {
              db.deleteObjectStore("FileStorage");
            }
            const store = db.createObjectStore("FileStorage", { keyPath: "path" });
            store.createIndex("by_folder", "folder");
          }
        }
      }
      async dbRequest(cmd, args) {
        const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? "readwrite" : "readonly";
        return this.initDb().then((conn) => {
          return new Promise((resolve2, reject) => {
            const tx = conn.transaction(["FileStorage"], readFlag);
            const store = tx.objectStore("FileStorage");
            const req = store[cmd](...args);
            req.onsuccess = () => resolve2(req.result);
            req.onerror = () => reject(req.error);
          });
        });
      }
      async dbIndexRequest(indexName, cmd, args) {
        const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? "readwrite" : "readonly";
        return this.initDb().then((conn) => {
          return new Promise((resolve2, reject) => {
            const tx = conn.transaction(["FileStorage"], readFlag);
            const store = tx.objectStore("FileStorage");
            const index = store.index(indexName);
            const req = index[cmd](...args);
            req.onsuccess = () => resolve2(req.result);
            req.onerror = () => reject(req.error);
          });
        });
      }
      getPath(directory, uriPath) {
        const cleanedUriPath = uriPath !== void 0 ? uriPath.replace(/^[/]+|[/]+$/g, "") : "";
        let fsPath = "";
        if (directory !== void 0)
          fsPath += "/" + directory;
        if (uriPath !== "")
          fsPath += "/" + cleanedUriPath;
        return fsPath;
      }
      async clear() {
        const conn = await this.initDb();
        const tx = conn.transaction(["FileStorage"], "readwrite");
        const store = tx.objectStore("FileStorage");
        store.clear();
      }
      /**
       * Read a file from disk
       * @param options options for the file read
       * @return a promise that resolves with the read file data result
       */
      async readFile(options) {
        const path2 = this.getPath(options.directory, options.path);
        const entry = await this.dbRequest("get", [path2]);
        if (entry === void 0)
          throw Error("File does not exist.");
        return { data: entry.content ? entry.content : "" };
      }
      /**
       * Write a file to disk in the specified location on device
       * @param options options for the file write
       * @return a promise that resolves with the file write result
       */
      async writeFile(options) {
        const path2 = this.getPath(options.directory, options.path);
        let data = options.data;
        const encoding = options.encoding;
        const doRecursive = options.recursive;
        const occupiedEntry = await this.dbRequest("get", [path2]);
        if (occupiedEntry && occupiedEntry.type === "directory")
          throw Error("The supplied path is a directory.");
        const parentPath = path2.substr(0, path2.lastIndexOf("/"));
        const parentEntry = await this.dbRequest("get", [parentPath]);
        if (parentEntry === void 0) {
          const subDirIndex = parentPath.indexOf("/", 1);
          if (subDirIndex !== -1) {
            const parentArgPath = parentPath.substr(subDirIndex);
            await this.mkdir({
              path: parentArgPath,
              directory: options.directory,
              recursive: doRecursive
            });
          }
        }
        if (!encoding && !(data instanceof Blob)) {
          data = data.indexOf(",") >= 0 ? data.split(",")[1] : data;
          if (!this.isBase64String(data))
            throw Error("The supplied data is not valid base64 content.");
        }
        const now = Date.now();
        const pathObj = {
          path: path2,
          folder: parentPath,
          type: "file",
          size: data instanceof Blob ? data.size : data.length,
          ctime: now,
          mtime: now,
          content: data
        };
        await this.dbRequest("put", [pathObj]);
        return {
          uri: pathObj.path
        };
      }
      /**
       * Append to a file on disk in the specified location on device
       * @param options options for the file append
       * @return a promise that resolves with the file write result
       */
      async appendFile(options) {
        const path2 = this.getPath(options.directory, options.path);
        let data = options.data;
        const encoding = options.encoding;
        const parentPath = path2.substr(0, path2.lastIndexOf("/"));
        const now = Date.now();
        let ctime = now;
        const occupiedEntry = await this.dbRequest("get", [path2]);
        if (occupiedEntry && occupiedEntry.type === "directory")
          throw Error("The supplied path is a directory.");
        const parentEntry = await this.dbRequest("get", [parentPath]);
        if (parentEntry === void 0) {
          const subDirIndex = parentPath.indexOf("/", 1);
          if (subDirIndex !== -1) {
            const parentArgPath = parentPath.substr(subDirIndex);
            await this.mkdir({
              path: parentArgPath,
              directory: options.directory,
              recursive: true
            });
          }
        }
        if (!encoding && !this.isBase64String(data))
          throw Error("The supplied data is not valid base64 content.");
        if (occupiedEntry !== void 0) {
          if (occupiedEntry.content instanceof Blob) {
            throw Error("The occupied entry contains a Blob object which cannot be appended to.");
          }
          if (occupiedEntry.content !== void 0 && !encoding) {
            data = btoa(atob(occupiedEntry.content) + atob(data));
          } else {
            data = occupiedEntry.content + data;
          }
          ctime = occupiedEntry.ctime;
        }
        const pathObj = {
          path: path2,
          folder: parentPath,
          type: "file",
          size: data.length,
          ctime,
          mtime: now,
          content: data
        };
        await this.dbRequest("put", [pathObj]);
      }
      /**
       * Delete a file from disk
       * @param options options for the file delete
       * @return a promise that resolves with the deleted file data result
       */
      async deleteFile(options) {
        const path2 = this.getPath(options.directory, options.path);
        const entry = await this.dbRequest("get", [path2]);
        if (entry === void 0)
          throw Error("File does not exist.");
        const entries = await this.dbIndexRequest("by_folder", "getAllKeys", [IDBKeyRange.only(path2)]);
        if (entries.length !== 0)
          throw Error("Folder is not empty.");
        await this.dbRequest("delete", [path2]);
      }
      /**
       * Create a directory.
       * @param options options for the mkdir
       * @return a promise that resolves with the mkdir result
       */
      async mkdir(options) {
        const path2 = this.getPath(options.directory, options.path);
        const doRecursive = options.recursive;
        const parentPath = path2.substr(0, path2.lastIndexOf("/"));
        const depth = (path2.match(/\//g) || []).length;
        const parentEntry = await this.dbRequest("get", [parentPath]);
        const occupiedEntry = await this.dbRequest("get", [path2]);
        if (depth === 1)
          throw Error("Cannot create Root directory");
        if (occupiedEntry !== void 0)
          throw Error("Current directory does already exist.");
        if (!doRecursive && depth !== 2 && parentEntry === void 0)
          throw Error("Parent directory must exist");
        if (doRecursive && depth !== 2 && parentEntry === void 0) {
          const parentArgPath = parentPath.substr(parentPath.indexOf("/", 1));
          await this.mkdir({
            path: parentArgPath,
            directory: options.directory,
            recursive: doRecursive
          });
        }
        const now = Date.now();
        const pathObj = {
          path: path2,
          folder: parentPath,
          type: "directory",
          size: 0,
          ctime: now,
          mtime: now
        };
        await this.dbRequest("put", [pathObj]);
      }
      /**
       * Remove a directory
       * @param options the options for the directory remove
       */
      async rmdir(options) {
        const { path: path2, directory, recursive } = options;
        const fullPath = this.getPath(directory, path2);
        const entry = await this.dbRequest("get", [fullPath]);
        if (entry === void 0)
          throw Error("Folder does not exist.");
        if (entry.type !== "directory")
          throw Error("Requested path is not a directory");
        const readDirResult = await this.readdir({ path: path2, directory });
        if (readDirResult.files.length !== 0 && !recursive)
          throw Error("Folder is not empty");
        for (const entry2 of readDirResult.files) {
          const entryPath = `${path2}/${entry2.name}`;
          const entryObj = await this.stat({ path: entryPath, directory });
          if (entryObj.type === "file") {
            await this.deleteFile({ path: entryPath, directory });
          } else {
            await this.rmdir({ path: entryPath, directory, recursive });
          }
        }
        await this.dbRequest("delete", [fullPath]);
      }
      /**
       * Return a list of files from the directory (not recursive)
       * @param options the options for the readdir operation
       * @return a promise that resolves with the readdir directory listing result
       */
      async readdir(options) {
        const path2 = this.getPath(options.directory, options.path);
        const entry = await this.dbRequest("get", [path2]);
        if (options.path !== "" && entry === void 0)
          throw Error("Folder does not exist.");
        const entries = await this.dbIndexRequest("by_folder", "getAllKeys", [IDBKeyRange.only(path2)]);
        const files = await Promise.all(entries.map(async (e) => {
          let subEntry = await this.dbRequest("get", [e]);
          if (subEntry === void 0) {
            subEntry = await this.dbRequest("get", [e + "/"]);
          }
          return {
            name: e.substring(path2.length + 1),
            type: subEntry.type,
            size: subEntry.size,
            ctime: subEntry.ctime,
            mtime: subEntry.mtime,
            uri: subEntry.path
          };
        }));
        return { files };
      }
      /**
       * Return full File URI for a path and directory
       * @param options the options for the stat operation
       * @return a promise that resolves with the file stat result
       */
      async getUri(options) {
        const path2 = this.getPath(options.directory, options.path);
        let entry = await this.dbRequest("get", [path2]);
        if (entry === void 0) {
          entry = await this.dbRequest("get", [path2 + "/"]);
        }
        return {
          uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path2
        };
      }
      /**
       * Return data about a file
       * @param options the options for the stat operation
       * @return a promise that resolves with the file stat result
       */
      async stat(options) {
        const path2 = this.getPath(options.directory, options.path);
        let entry = await this.dbRequest("get", [path2]);
        if (entry === void 0) {
          entry = await this.dbRequest("get", [path2 + "/"]);
        }
        if (entry === void 0)
          throw Error("Entry does not exist.");
        return {
          name: entry.path.substring(path2.length + 1),
          type: entry.type,
          size: entry.size,
          ctime: entry.ctime,
          mtime: entry.mtime,
          uri: entry.path
        };
      }
      /**
       * Rename a file or directory
       * @param options the options for the rename operation
       * @return a promise that resolves with the rename result
       */
      async rename(options) {
        await this._copy(options, true);
        return;
      }
      /**
       * Copy a file or directory
       * @param options the options for the copy operation
       * @return a promise that resolves with the copy result
       */
      async copy(options) {
        return this._copy(options, false);
      }
      async requestPermissions() {
        return { publicStorage: "granted" };
      }
      async checkPermissions() {
        return { publicStorage: "granted" };
      }
      /**
       * Function that can perform a copy or a rename
       * @param options the options for the rename operation
       * @param doRename whether to perform a rename or copy operation
       * @return a promise that resolves with the result
       */
      async _copy(options, doRename = false) {
        let { toDirectory } = options;
        const { to, from, directory: fromDirectory } = options;
        if (!to || !from) {
          throw Error("Both to and from must be provided");
        }
        if (!toDirectory) {
          toDirectory = fromDirectory;
        }
        const fromPath = this.getPath(fromDirectory, from);
        const toPath = this.getPath(toDirectory, to);
        if (fromPath === toPath) {
          return {
            uri: toPath
          };
        }
        if (isPathParent(fromPath, toPath)) {
          throw Error("To path cannot contain the from path");
        }
        let toObj;
        try {
          toObj = await this.stat({
            path: to,
            directory: toDirectory
          });
        } catch (e) {
          const toPathComponents = to.split("/");
          toPathComponents.pop();
          const toPath2 = toPathComponents.join("/");
          if (toPathComponents.length > 0) {
            const toParentDirectory = await this.stat({
              path: toPath2,
              directory: toDirectory
            });
            if (toParentDirectory.type !== "directory") {
              throw new Error("Parent directory of the to path is a file");
            }
          }
        }
        if (toObj && toObj.type === "directory") {
          throw new Error("Cannot overwrite a directory with a file");
        }
        const fromObj = await this.stat({
          path: from,
          directory: fromDirectory
        });
        const updateTime = async (path2, ctime2, mtime) => {
          const fullPath = this.getPath(toDirectory, path2);
          const entry = await this.dbRequest("get", [fullPath]);
          entry.ctime = ctime2;
          entry.mtime = mtime;
          await this.dbRequest("put", [entry]);
        };
        const ctime = fromObj.ctime ? fromObj.ctime : Date.now();
        switch (fromObj.type) {
          case "file": {
            const file = await this.readFile({
              path: from,
              directory: fromDirectory
            });
            if (doRename) {
              await this.deleteFile({
                path: from,
                directory: fromDirectory
              });
            }
            let encoding;
            if (!(file.data instanceof Blob) && !this.isBase64String(file.data)) {
              encoding = Encoding.UTF8;
            }
            const writeResult = await this.writeFile({
              path: to,
              directory: toDirectory,
              data: file.data,
              encoding
            });
            if (doRename) {
              await updateTime(to, ctime, fromObj.mtime);
            }
            return writeResult;
          }
          case "directory": {
            if (toObj) {
              throw Error("Cannot move a directory over an existing object");
            }
            try {
              await this.mkdir({
                path: to,
                directory: toDirectory,
                recursive: false
              });
              if (doRename) {
                await updateTime(to, ctime, fromObj.mtime);
              }
            } catch (e) {
            }
            const contents = (await this.readdir({
              path: from,
              directory: fromDirectory
            })).files;
            for (const filename of contents) {
              await this._copy({
                from: `${from}/${filename.name}`,
                to: `${to}/${filename.name}`,
                directory: fromDirectory,
                toDirectory
              }, doRename);
            }
            if (doRename) {
              await this.rmdir({
                path: from,
                directory: fromDirectory
              });
            }
          }
        }
        return {
          uri: toPath
        };
      }
      isBase64String(str) {
        try {
          return btoa(atob(str)) == str;
        } catch (err) {
          return false;
        }
      }
    };
    FilesystemWeb._debug = true;
  }
});

// node_modules/node-machine-id/dist/index.js
var require_dist = __commonJS({
  "node_modules/node-machine-id/dist/index.js"(exports, module2) {
    !function(t, n) {
      "object" == typeof exports && "object" == typeof module2 ? module2.exports = n(require("child_process"), require("crypto")) : "function" == typeof define && define.amd ? define(["child_process", "crypto"], n) : "object" == typeof exports ? exports["electron-machine-id"] = n(require("child_process"), require("crypto")) : t["electron-machine-id"] = n(t.child_process, t.crypto);
    }(exports, function(t, n) {
      return function(t2) {
        function n2(e) {
          if (r[e])
            return r[e].exports;
          var o = r[e] = { exports: {}, id: e, loaded: false };
          return t2[e].call(o.exports, o, o.exports, n2), o.loaded = true, o.exports;
        }
        var r = {};
        return n2.m = t2, n2.c = r, n2.p = "", n2(0);
      }([function(t2, n2, r) {
        t2.exports = r(34);
      }, function(t2, n2, r) {
        var e = r(29)("wks"), o = r(33), i = r(2).Symbol, c = "function" == typeof i, u2 = t2.exports = function(t3) {
          return e[t3] || (e[t3] = c && i[t3] || (c ? i : o)("Symbol." + t3));
        };
        u2.store = e;
      }, function(t2, n2) {
        var r = t2.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = r);
      }, function(t2, n2, r) {
        var e = r(9);
        t2.exports = function(t3) {
          if (!e(t3))
            throw TypeError(t3 + " is not an object!");
          return t3;
        };
      }, function(t2, n2, r) {
        t2.exports = !r(24)(function() {
          return 7 != Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(t2, n2, r) {
        var e = r(12), o = r(17);
        t2.exports = r(4) ? function(t3, n3, r2) {
          return e.f(t3, n3, o(1, r2));
        } : function(t3, n3, r2) {
          return t3[n3] = r2, t3;
        };
      }, function(t2, n2) {
        var r = t2.exports = { version: "2.4.0" };
        "number" == typeof __e && (__e = r);
      }, function(t2, n2, r) {
        var e = r(14);
        t2.exports = function(t3, n3, r2) {
          if (e(t3), void 0 === n3)
            return t3;
          switch (r2) {
            case 1:
              return function(r3) {
                return t3.call(n3, r3);
              };
            case 2:
              return function(r3, e2) {
                return t3.call(n3, r3, e2);
              };
            case 3:
              return function(r3, e2, o) {
                return t3.call(n3, r3, e2, o);
              };
          }
          return function() {
            return t3.apply(n3, arguments);
          };
        };
      }, function(t2, n2) {
        var r = {}.hasOwnProperty;
        t2.exports = function(t3, n3) {
          return r.call(t3, n3);
        };
      }, function(t2, n2) {
        t2.exports = function(t3) {
          return "object" == typeof t3 ? null !== t3 : "function" == typeof t3;
        };
      }, function(t2, n2) {
        t2.exports = {};
      }, function(t2, n2) {
        var r = {}.toString;
        t2.exports = function(t3) {
          return r.call(t3).slice(8, -1);
        };
      }, function(t2, n2, r) {
        var e = r(3), o = r(26), i = r(32), c = Object.defineProperty;
        n2.f = r(4) ? Object.defineProperty : function(t3, n3, r2) {
          if (e(t3), n3 = i(n3, true), e(r2), o)
            try {
              return c(t3, n3, r2);
            } catch (t4) {
            }
          if ("get" in r2 || "set" in r2)
            throw TypeError("Accessors not supported!");
          return "value" in r2 && (t3[n3] = r2.value), t3;
        };
      }, function(t2, n2, r) {
        var e = r(42), o = r(15);
        t2.exports = function(t3) {
          return e(o(t3));
        };
      }, function(t2, n2) {
        t2.exports = function(t3) {
          if ("function" != typeof t3)
            throw TypeError(t3 + " is not a function!");
          return t3;
        };
      }, function(t2, n2) {
        t2.exports = function(t3) {
          if (void 0 == t3)
            throw TypeError("Can't call method on  " + t3);
          return t3;
        };
      }, function(t2, n2, r) {
        var e = r(9), o = r(2).document, i = e(o) && e(o.createElement);
        t2.exports = function(t3) {
          return i ? o.createElement(t3) : {};
        };
      }, function(t2, n2) {
        t2.exports = function(t3, n3) {
          return { enumerable: !(1 & t3), configurable: !(2 & t3), writable: !(4 & t3), value: n3 };
        };
      }, function(t2, n2, r) {
        var e = r(12).f, o = r(8), i = r(1)("toStringTag");
        t2.exports = function(t3, n3, r2) {
          t3 && !o(t3 = r2 ? t3 : t3.prototype, i) && e(t3, i, { configurable: true, value: n3 });
        };
      }, function(t2, n2, r) {
        var e = r(29)("keys"), o = r(33);
        t2.exports = function(t3) {
          return e[t3] || (e[t3] = o(t3));
        };
      }, function(t2, n2) {
        var r = Math.ceil, e = Math.floor;
        t2.exports = function(t3) {
          return isNaN(t3 = +t3) ? 0 : (t3 > 0 ? e : r)(t3);
        };
      }, function(t2, n2, r) {
        var e = r(11), o = r(1)("toStringTag"), i = "Arguments" == e(function() {
          return arguments;
        }()), c = function(t3, n3) {
          try {
            return t3[n3];
          } catch (t4) {
          }
        };
        t2.exports = function(t3) {
          var n3, r2, u2;
          return void 0 === t3 ? "Undefined" : null === t3 ? "Null" : "string" == typeof (r2 = c(n3 = Object(t3), o)) ? r2 : i ? e(n3) : "Object" == (u2 = e(n3)) && "function" == typeof n3.callee ? "Arguments" : u2;
        };
      }, function(t2, n2) {
        t2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      }, function(t2, n2, r) {
        var e = r(2), o = r(6), i = r(7), c = r(5), u2 = "prototype", s2 = function(t3, n3, r2) {
          var f, a, p, l = t3 & s2.F, v = t3 & s2.G, h = t3 & s2.S, d = t3 & s2.P, y2 = t3 & s2.B, _ = t3 & s2.W, x = v ? o : o[n3] || (o[n3] = {}), m = x[u2], w = v ? e : h ? e[n3] : (e[n3] || {})[u2];
          v && (r2 = n3);
          for (f in r2)
            a = !l && w && void 0 !== w[f], a && f in x || (p = a ? w[f] : r2[f], x[f] = v && "function" != typeof w[f] ? r2[f] : y2 && a ? i(p, e) : _ && w[f] == p ? function(t4) {
              var n4 = function(n5, r3, e2) {
                if (this instanceof t4) {
                  switch (arguments.length) {
                    case 0:
                      return new t4();
                    case 1:
                      return new t4(n5);
                    case 2:
                      return new t4(n5, r3);
                  }
                  return new t4(n5, r3, e2);
                }
                return t4.apply(this, arguments);
              };
              return n4[u2] = t4[u2], n4;
            }(p) : d && "function" == typeof p ? i(Function.call, p) : p, d && ((x.virtual || (x.virtual = {}))[f] = p, t3 & s2.R && m && !m[f] && c(m, f, p)));
        };
        s2.F = 1, s2.G = 2, s2.S = 4, s2.P = 8, s2.B = 16, s2.W = 32, s2.U = 64, s2.R = 128, t2.exports = s2;
      }, function(t2, n2) {
        t2.exports = function(t3) {
          try {
            return !!t3();
          } catch (t4) {
            return true;
          }
        };
      }, function(t2, n2, r) {
        t2.exports = r(2).document && document.documentElement;
      }, function(t2, n2, r) {
        t2.exports = !r(4) && !r(24)(function() {
          return 7 != Object.defineProperty(r(16)("div"), "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(t2, n2, r) {
        "use strict";
        var e = r(28), o = r(23), i = r(57), c = r(5), u2 = r(8), s2 = r(10), f = r(45), a = r(18), p = r(52), l = r(1)("iterator"), v = !([].keys && "next" in [].keys()), h = "@@iterator", d = "keys", y2 = "values", _ = function() {
          return this;
        };
        t2.exports = function(t3, n3, r2, x, m, w, g) {
          f(r2, n3, x);
          var b, O, j, S = function(t4) {
            if (!v && t4 in T)
              return T[t4];
            switch (t4) {
              case d:
                return function() {
                  return new r2(this, t4);
                };
              case y2:
                return function() {
                  return new r2(this, t4);
                };
            }
            return function() {
              return new r2(this, t4);
            };
          }, E = n3 + " Iterator", P = m == y2, M = false, T = t3.prototype, A = T[l] || T[h] || m && T[m], k = A || S(m), C = m ? P ? S("entries") : k : void 0, I = "Array" == n3 ? T.entries || A : A;
          if (I && (j = p(I.call(new t3())), j !== Object.prototype && (a(j, E, true), e || u2(j, l) || c(j, l, _))), P && A && A.name !== y2 && (M = true, k = function() {
            return A.call(this);
          }), e && !g || !v && !M && T[l] || c(T, l, k), s2[n3] = k, s2[E] = _, m)
            if (b = { values: P ? k : S(y2), keys: w ? k : S(d), entries: C }, g)
              for (O in b)
                O in T || i(T, O, b[O]);
            else
              o(o.P + o.F * (v || M), n3, b);
          return b;
        };
      }, function(t2, n2) {
        t2.exports = true;
      }, function(t2, n2, r) {
        var e = r(2), o = "__core-js_shared__", i = e[o] || (e[o] = {});
        t2.exports = function(t3) {
          return i[t3] || (i[t3] = {});
        };
      }, function(t2, n2, r) {
        var e, o, i, c = r(7), u2 = r(41), s2 = r(25), f = r(16), a = r(2), p = a.process, l = a.setImmediate, v = a.clearImmediate, h = a.MessageChannel, d = 0, y2 = {}, _ = "onreadystatechange", x = function() {
          var t3 = +this;
          if (y2.hasOwnProperty(t3)) {
            var n3 = y2[t3];
            delete y2[t3], n3();
          }
        }, m = function(t3) {
          x.call(t3.data);
        };
        l && v || (l = function(t3) {
          for (var n3 = [], r2 = 1; arguments.length > r2; )
            n3.push(arguments[r2++]);
          return y2[++d] = function() {
            u2("function" == typeof t3 ? t3 : Function(t3), n3);
          }, e(d), d;
        }, v = function(t3) {
          delete y2[t3];
        }, "process" == r(11)(p) ? e = function(t3) {
          p.nextTick(c(x, t3, 1));
        } : h ? (o = new h(), i = o.port2, o.port1.onmessage = m, e = c(i.postMessage, i, 1)) : a.addEventListener && "function" == typeof postMessage && !a.importScripts ? (e = function(t3) {
          a.postMessage(t3 + "", "*");
        }, a.addEventListener("message", m, false)) : e = _ in f("script") ? function(t3) {
          s2.appendChild(f("script"))[_] = function() {
            s2.removeChild(this), x.call(t3);
          };
        } : function(t3) {
          setTimeout(c(x, t3, 1), 0);
        }), t2.exports = { set: l, clear: v };
      }, function(t2, n2, r) {
        var e = r(20), o = Math.min;
        t2.exports = function(t3) {
          return t3 > 0 ? o(e(t3), 9007199254740991) : 0;
        };
      }, function(t2, n2, r) {
        var e = r(9);
        t2.exports = function(t3, n3) {
          if (!e(t3))
            return t3;
          var r2, o;
          if (n3 && "function" == typeof (r2 = t3.toString) && !e(o = r2.call(t3)))
            return o;
          if ("function" == typeof (r2 = t3.valueOf) && !e(o = r2.call(t3)))
            return o;
          if (!n3 && "function" == typeof (r2 = t3.toString) && !e(o = r2.call(t3)))
            return o;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(t2, n2) {
        var r = 0, e = Math.random();
        t2.exports = function(t3) {
          return "Symbol(".concat(void 0 === t3 ? "" : t3, ")_", (++r + e).toString(36));
        };
      }, function(t2, n2, r) {
        "use strict";
        function e(t3) {
          return t3 && t3.__esModule ? t3 : { default: t3 };
        }
        function o() {
          return "win32" !== process.platform ? "" : "ia32" === process.arch && process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432") ? "mixed" : "native";
        }
        function i(t3) {
          return (0, l.createHash)("sha256").update(t3).digest("hex");
        }
        function c(t3) {
          switch (h) {
            case "darwin":
              return t3.split("IOPlatformUUID")[1].split("\n")[0].replace(/\=|\s+|\"/gi, "").toLowerCase();
            case "win32":
              return t3.toString().split("REG_SZ")[1].replace(/\r+|\n+|\s+/gi, "").toLowerCase();
            case "linux":
              return t3.toString().replace(/\r+|\n+|\s+/gi, "").toLowerCase();
            case "freebsd":
              return t3.toString().replace(/\r+|\n+|\s+/gi, "").toLowerCase();
            default:
              throw new Error("Unsupported platform: " + process.platform);
          }
        }
        function u2(t3) {
          var n3 = c((0, p.execSync)(y2[h]).toString());
          return t3 ? n3 : i(n3);
        }
        function s2(t3) {
          return new a.default(function(n3, r2) {
            return (0, p.exec)(y2[h], {}, function(e2, o2, u3) {
              if (e2)
                return r2(new Error("Error while obtaining machine id: " + e2.stack));
              var s3 = c(o2.toString());
              return n3(t3 ? s3 : i(s3));
            });
          });
        }
        Object.defineProperty(n2, "__esModule", { value: true });
        var f = r(35), a = e(f);
        n2.machineIdSync = u2, n2.machineId = s2;
        var p = r(70), l = r(71), v = process, h = v.platform, d = { native: "%windir%\\System32", mixed: "%windir%\\sysnative\\cmd.exe /c %windir%\\System32" }, y2 = { darwin: "ioreg -rd1 -c IOPlatformExpertDevice", win32: d[o()] + "\\REG.exe QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid", linux: "( cat /var/lib/dbus/machine-id /etc/machine-id 2> /dev/null || hostname ) | head -n 1 || :", freebsd: "kenv -q smbios.system.uuid || sysctl -n kern.hostuuid" };
      }, function(t2, n2, r) {
        t2.exports = { default: r(36), __esModule: true };
      }, function(t2, n2, r) {
        r(66), r(68), r(69), r(67), t2.exports = r(6).Promise;
      }, function(t2, n2) {
        t2.exports = function() {
        };
      }, function(t2, n2) {
        t2.exports = function(t3, n3, r, e) {
          if (!(t3 instanceof n3) || void 0 !== e && e in t3)
            throw TypeError(r + ": incorrect invocation!");
          return t3;
        };
      }, function(t2, n2, r) {
        var e = r(13), o = r(31), i = r(62);
        t2.exports = function(t3) {
          return function(n3, r2, c) {
            var u2, s2 = e(n3), f = o(s2.length), a = i(c, f);
            if (t3 && r2 != r2) {
              for (; f > a; )
                if (u2 = s2[a++], u2 != u2)
                  return true;
            } else
              for (; f > a; a++)
                if ((t3 || a in s2) && s2[a] === r2)
                  return t3 || a || 0;
            return !t3 && -1;
          };
        };
      }, function(t2, n2, r) {
        var e = r(7), o = r(44), i = r(43), c = r(3), u2 = r(31), s2 = r(64), f = {}, a = {}, n2 = t2.exports = function(t3, n3, r2, p, l) {
          var v, h, d, y2, _ = l ? function() {
            return t3;
          } : s2(t3), x = e(r2, p, n3 ? 2 : 1), m = 0;
          if ("function" != typeof _)
            throw TypeError(t3 + " is not iterable!");
          if (i(_)) {
            for (v = u2(t3.length); v > m; m++)
              if (y2 = n3 ? x(c(h = t3[m])[0], h[1]) : x(t3[m]), y2 === f || y2 === a)
                return y2;
          } else
            for (d = _.call(t3); !(h = d.next()).done; )
              if (y2 = o(d, x, h.value, n3), y2 === f || y2 === a)
                return y2;
        };
        n2.BREAK = f, n2.RETURN = a;
      }, function(t2, n2) {
        t2.exports = function(t3, n3, r) {
          var e = void 0 === r;
          switch (n3.length) {
            case 0:
              return e ? t3() : t3.call(r);
            case 1:
              return e ? t3(n3[0]) : t3.call(r, n3[0]);
            case 2:
              return e ? t3(n3[0], n3[1]) : t3.call(r, n3[0], n3[1]);
            case 3:
              return e ? t3(n3[0], n3[1], n3[2]) : t3.call(r, n3[0], n3[1], n3[2]);
            case 4:
              return e ? t3(n3[0], n3[1], n3[2], n3[3]) : t3.call(r, n3[0], n3[1], n3[2], n3[3]);
          }
          return t3.apply(r, n3);
        };
      }, function(t2, n2, r) {
        var e = r(11);
        t2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t3) {
          return "String" == e(t3) ? t3.split("") : Object(t3);
        };
      }, function(t2, n2, r) {
        var e = r(10), o = r(1)("iterator"), i = Array.prototype;
        t2.exports = function(t3) {
          return void 0 !== t3 && (e.Array === t3 || i[o] === t3);
        };
      }, function(t2, n2, r) {
        var e = r(3);
        t2.exports = function(t3, n3, r2, o) {
          try {
            return o ? n3(e(r2)[0], r2[1]) : n3(r2);
          } catch (n4) {
            var i = t3.return;
            throw void 0 !== i && e(i.call(t3)), n4;
          }
        };
      }, function(t2, n2, r) {
        "use strict";
        var e = r(49), o = r(17), i = r(18), c = {};
        r(5)(c, r(1)("iterator"), function() {
          return this;
        }), t2.exports = function(t3, n3, r2) {
          t3.prototype = e(c, { next: o(1, r2) }), i(t3, n3 + " Iterator");
        };
      }, function(t2, n2, r) {
        var e = r(1)("iterator"), o = false;
        try {
          var i = [7][e]();
          i.return = function() {
            o = true;
          }, Array.from(i, function() {
            throw 2;
          });
        } catch (t3) {
        }
        t2.exports = function(t3, n3) {
          if (!n3 && !o)
            return false;
          var r2 = false;
          try {
            var i2 = [7], c = i2[e]();
            c.next = function() {
              return { done: r2 = true };
            }, i2[e] = function() {
              return c;
            }, t3(i2);
          } catch (t4) {
          }
          return r2;
        };
      }, function(t2, n2) {
        t2.exports = function(t3, n3) {
          return { value: n3, done: !!t3 };
        };
      }, function(t2, n2, r) {
        var e = r(2), o = r(30).set, i = e.MutationObserver || e.WebKitMutationObserver, c = e.process, u2 = e.Promise, s2 = "process" == r(11)(c);
        t2.exports = function() {
          var t3, n3, r2, f = function() {
            var e2, o2;
            for (s2 && (e2 = c.domain) && e2.exit(); t3; ) {
              o2 = t3.fn, t3 = t3.next;
              try {
                o2();
              } catch (e3) {
                throw t3 ? r2() : n3 = void 0, e3;
              }
            }
            n3 = void 0, e2 && e2.enter();
          };
          if (s2)
            r2 = function() {
              c.nextTick(f);
            };
          else if (i) {
            var a = true, p = document.createTextNode("");
            new i(f).observe(p, { characterData: true }), r2 = function() {
              p.data = a = !a;
            };
          } else if (u2 && u2.resolve) {
            var l = u2.resolve();
            r2 = function() {
              l.then(f);
            };
          } else
            r2 = function() {
              o.call(e, f);
            };
          return function(e2) {
            var o2 = { fn: e2, next: void 0 };
            n3 && (n3.next = o2), t3 || (t3 = o2, r2()), n3 = o2;
          };
        };
      }, function(t2, n2, r) {
        var e = r(3), o = r(50), i = r(22), c = r(19)("IE_PROTO"), u2 = function() {
        }, s2 = "prototype", f = function() {
          var t3, n3 = r(16)("iframe"), e2 = i.length, o2 = ">";
          for (n3.style.display = "none", r(25).appendChild(n3), n3.src = "javascript:", t3 = n3.contentWindow.document, t3.open(), t3.write("<script>document.F=Object<\/script" + o2), t3.close(), f = t3.F; e2--; )
            delete f[s2][i[e2]];
          return f();
        };
        t2.exports = Object.create || function(t3, n3) {
          var r2;
          return null !== t3 ? (u2[s2] = e(t3), r2 = new u2(), u2[s2] = null, r2[c] = t3) : r2 = f(), void 0 === n3 ? r2 : o(r2, n3);
        };
      }, function(t2, n2, r) {
        var e = r(12), o = r(3), i = r(54);
        t2.exports = r(4) ? Object.defineProperties : function(t3, n3) {
          o(t3);
          for (var r2, c = i(n3), u2 = c.length, s2 = 0; u2 > s2; )
            e.f(t3, r2 = c[s2++], n3[r2]);
          return t3;
        };
      }, function(t2, n2, r) {
        var e = r(55), o = r(17), i = r(13), c = r(32), u2 = r(8), s2 = r(26), f = Object.getOwnPropertyDescriptor;
        n2.f = r(4) ? f : function(t3, n3) {
          if (t3 = i(t3), n3 = c(n3, true), s2)
            try {
              return f(t3, n3);
            } catch (t4) {
            }
          if (u2(t3, n3))
            return o(!e.f.call(t3, n3), t3[n3]);
        };
      }, function(t2, n2, r) {
        var e = r(8), o = r(63), i = r(19)("IE_PROTO"), c = Object.prototype;
        t2.exports = Object.getPrototypeOf || function(t3) {
          return t3 = o(t3), e(t3, i) ? t3[i] : "function" == typeof t3.constructor && t3 instanceof t3.constructor ? t3.constructor.prototype : t3 instanceof Object ? c : null;
        };
      }, function(t2, n2, r) {
        var e = r(8), o = r(13), i = r(39)(false), c = r(19)("IE_PROTO");
        t2.exports = function(t3, n3) {
          var r2, u2 = o(t3), s2 = 0, f = [];
          for (r2 in u2)
            r2 != c && e(u2, r2) && f.push(r2);
          for (; n3.length > s2; )
            e(u2, r2 = n3[s2++]) && (~i(f, r2) || f.push(r2));
          return f;
        };
      }, function(t2, n2, r) {
        var e = r(53), o = r(22);
        t2.exports = Object.keys || function(t3) {
          return e(t3, o);
        };
      }, function(t2, n2) {
        n2.f = {}.propertyIsEnumerable;
      }, function(t2, n2, r) {
        var e = r(5);
        t2.exports = function(t3, n3, r2) {
          for (var o in n3)
            r2 && t3[o] ? t3[o] = n3[o] : e(t3, o, n3[o]);
          return t3;
        };
      }, function(t2, n2, r) {
        t2.exports = r(5);
      }, function(t2, n2, r) {
        var e = r(9), o = r(3), i = function(t3, n3) {
          if (o(t3), !e(n3) && null !== n3)
            throw TypeError(n3 + ": can't set as prototype!");
        };
        t2.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function(t3, n3, e2) {
          try {
            e2 = r(7)(Function.call, r(51).f(Object.prototype, "__proto__").set, 2), e2(t3, []), n3 = !(t3 instanceof Array);
          } catch (t4) {
            n3 = true;
          }
          return function(t4, r2) {
            return i(t4, r2), n3 ? t4.__proto__ = r2 : e2(t4, r2), t4;
          };
        }({}, false) : void 0), check: i };
      }, function(t2, n2, r) {
        "use strict";
        var e = r(2), o = r(6), i = r(12), c = r(4), u2 = r(1)("species");
        t2.exports = function(t3) {
          var n3 = "function" == typeof o[t3] ? o[t3] : e[t3];
          c && n3 && !n3[u2] && i.f(n3, u2, { configurable: true, get: function() {
            return this;
          } });
        };
      }, function(t2, n2, r) {
        var e = r(3), o = r(14), i = r(1)("species");
        t2.exports = function(t3, n3) {
          var r2, c = e(t3).constructor;
          return void 0 === c || void 0 == (r2 = e(c)[i]) ? n3 : o(r2);
        };
      }, function(t2, n2, r) {
        var e = r(20), o = r(15);
        t2.exports = function(t3) {
          return function(n3, r2) {
            var i, c, u2 = String(o(n3)), s2 = e(r2), f = u2.length;
            return s2 < 0 || s2 >= f ? t3 ? "" : void 0 : (i = u2.charCodeAt(s2), i < 55296 || i > 56319 || s2 + 1 === f || (c = u2.charCodeAt(s2 + 1)) < 56320 || c > 57343 ? t3 ? u2.charAt(s2) : i : t3 ? u2.slice(s2, s2 + 2) : (i - 55296 << 10) + (c - 56320) + 65536);
          };
        };
      }, function(t2, n2, r) {
        var e = r(20), o = Math.max, i = Math.min;
        t2.exports = function(t3, n3) {
          return t3 = e(t3), t3 < 0 ? o(t3 + n3, 0) : i(t3, n3);
        };
      }, function(t2, n2, r) {
        var e = r(15);
        t2.exports = function(t3) {
          return Object(e(t3));
        };
      }, function(t2, n2, r) {
        var e = r(21), o = r(1)("iterator"), i = r(10);
        t2.exports = r(6).getIteratorMethod = function(t3) {
          if (void 0 != t3)
            return t3[o] || t3["@@iterator"] || i[e(t3)];
        };
      }, function(t2, n2, r) {
        "use strict";
        var e = r(37), o = r(47), i = r(10), c = r(13);
        t2.exports = r(27)(Array, "Array", function(t3, n3) {
          this._t = c(t3), this._i = 0, this._k = n3;
        }, function() {
          var t3 = this._t, n3 = this._k, r2 = this._i++;
          return !t3 || r2 >= t3.length ? (this._t = void 0, o(1)) : "keys" == n3 ? o(0, r2) : "values" == n3 ? o(0, t3[r2]) : o(0, [r2, t3[r2]]);
        }, "values"), i.Arguments = i.Array, e("keys"), e("values"), e("entries");
      }, function(t2, n2) {
      }, function(t2, n2, r) {
        "use strict";
        var e, o, i, c = r(28), u2 = r(2), s2 = r(7), f = r(21), a = r(23), p = r(9), l = (r(3), r(14)), v = r(38), h = r(40), d = (r(58).set, r(60)), y2 = r(30).set, _ = r(48)(), x = "Promise", m = u2.TypeError, w = u2.process, g = u2[x], w = u2.process, b = "process" == f(w), O = function() {
        }, j = !!function() {
          try {
            var t3 = g.resolve(1), n3 = (t3.constructor = {})[r(1)("species")] = function(t4) {
              t4(O, O);
            };
            return (b || "function" == typeof PromiseRejectionEvent) && t3.then(O) instanceof n3;
          } catch (t4) {
          }
        }(), S = function(t3, n3) {
          return t3 === n3 || t3 === g && n3 === i;
        }, E = function(t3) {
          var n3;
          return !(!p(t3) || "function" != typeof (n3 = t3.then)) && n3;
        }, P = function(t3) {
          return S(g, t3) ? new M(t3) : new o(t3);
        }, M = o = function(t3) {
          var n3, r2;
          this.promise = new t3(function(t4, e2) {
            if (void 0 !== n3 || void 0 !== r2)
              throw m("Bad Promise constructor");
            n3 = t4, r2 = e2;
          }), this.resolve = l(n3), this.reject = l(r2);
        }, T = function(t3) {
          try {
            t3();
          } catch (t4) {
            return { error: t4 };
          }
        }, A = function(t3, n3) {
          if (!t3._n) {
            t3._n = true;
            var r2 = t3._c;
            _(function() {
              for (var e2 = t3._v, o2 = 1 == t3._s, i2 = 0, c2 = function(n4) {
                var r3, i3, c3 = o2 ? n4.ok : n4.fail, u3 = n4.resolve, s3 = n4.reject, f2 = n4.domain;
                try {
                  c3 ? (o2 || (2 == t3._h && I(t3), t3._h = 1), c3 === true ? r3 = e2 : (f2 && f2.enter(), r3 = c3(e2), f2 && f2.exit()), r3 === n4.promise ? s3(m("Promise-chain cycle")) : (i3 = E(r3)) ? i3.call(r3, u3, s3) : u3(r3)) : s3(e2);
                } catch (t4) {
                  s3(t4);
                }
              }; r2.length > i2; )
                c2(r2[i2++]);
              t3._c = [], t3._n = false, n3 && !t3._h && k(t3);
            });
          }
        }, k = function(t3) {
          y2.call(u2, function() {
            var n3, r2, e2, o2 = t3._v;
            if (C(t3) && (n3 = T(function() {
              b ? w.emit("unhandledRejection", o2, t3) : (r2 = u2.onunhandledrejection) ? r2({ promise: t3, reason: o2 }) : (e2 = u2.console) && e2.error && e2.error("Unhandled promise rejection", o2);
            }), t3._h = b || C(t3) ? 2 : 1), t3._a = void 0, n3)
              throw n3.error;
          });
        }, C = function(t3) {
          if (1 == t3._h)
            return false;
          for (var n3, r2 = t3._a || t3._c, e2 = 0; r2.length > e2; )
            if (n3 = r2[e2++], n3.fail || !C(n3.promise))
              return false;
          return true;
        }, I = function(t3) {
          y2.call(u2, function() {
            var n3;
            b ? w.emit("rejectionHandled", t3) : (n3 = u2.onrejectionhandled) && n3({ promise: t3, reason: t3._v });
          });
        }, R = function(t3) {
          var n3 = this;
          n3._d || (n3._d = true, n3 = n3._w || n3, n3._v = t3, n3._s = 2, n3._a || (n3._a = n3._c.slice()), A(n3, true));
        }, F = function(t3) {
          var n3, r2 = this;
          if (!r2._d) {
            r2._d = true, r2 = r2._w || r2;
            try {
              if (r2 === t3)
                throw m("Promise can't be resolved itself");
              (n3 = E(t3)) ? _(function() {
                var e2 = { _w: r2, _d: false };
                try {
                  n3.call(t3, s2(F, e2, 1), s2(R, e2, 1));
                } catch (t4) {
                  R.call(e2, t4);
                }
              }) : (r2._v = t3, r2._s = 1, A(r2, false));
            } catch (t4) {
              R.call({ _w: r2, _d: false }, t4);
            }
          }
        };
        j || (g = function(t3) {
          v(this, g, x, "_h"), l(t3), e.call(this);
          try {
            t3(s2(F, this, 1), s2(R, this, 1));
          } catch (t4) {
            R.call(this, t4);
          }
        }, e = function(t3) {
          this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
        }, e.prototype = r(56)(g.prototype, { then: function(t3, n3) {
          var r2 = P(d(this, g));
          return r2.ok = "function" != typeof t3 || t3, r2.fail = "function" == typeof n3 && n3, r2.domain = b ? w.domain : void 0, this._c.push(r2), this._a && this._a.push(r2), this._s && A(this, false), r2.promise;
        }, catch: function(t3) {
          return this.then(void 0, t3);
        } }), M = function() {
          var t3 = new e();
          this.promise = t3, this.resolve = s2(F, t3, 1), this.reject = s2(R, t3, 1);
        }), a(a.G + a.W + a.F * !j, { Promise: g }), r(18)(g, x), r(59)(x), i = r(6)[x], a(a.S + a.F * !j, x, { reject: function(t3) {
          var n3 = P(this), r2 = n3.reject;
          return r2(t3), n3.promise;
        } }), a(a.S + a.F * (c || !j), x, { resolve: function(t3) {
          if (t3 instanceof g && S(t3.constructor, this))
            return t3;
          var n3 = P(this), r2 = n3.resolve;
          return r2(t3), n3.promise;
        } }), a(a.S + a.F * !(j && r(46)(function(t3) {
          g.all(t3).catch(O);
        })), x, { all: function(t3) {
          var n3 = this, r2 = P(n3), e2 = r2.resolve, o2 = r2.reject, i2 = T(function() {
            var r3 = [], i3 = 0, c2 = 1;
            h(t3, false, function(t4) {
              var u3 = i3++, s3 = false;
              r3.push(void 0), c2++, n3.resolve(t4).then(function(t5) {
                s3 || (s3 = true, r3[u3] = t5, --c2 || e2(r3));
              }, o2);
            }), --c2 || e2(r3);
          });
          return i2 && o2(i2.error), r2.promise;
        }, race: function(t3) {
          var n3 = this, r2 = P(n3), e2 = r2.reject, o2 = T(function() {
            h(t3, false, function(t4) {
              n3.resolve(t4).then(r2.resolve, e2);
            });
          });
          return o2 && e2(o2.error), r2.promise;
        } });
      }, function(t2, n2, r) {
        "use strict";
        var e = r(61)(true);
        r(27)(String, "String", function(t3) {
          this._t = String(t3), this._i = 0;
        }, function() {
          var t3, n3 = this._t, r2 = this._i;
          return r2 >= n3.length ? { value: void 0, done: true } : (t3 = e(n3, r2), this._i += t3.length, { value: t3, done: false });
        });
      }, function(t2, n2, r) {
        r(65);
        for (var e = r(2), o = r(5), i = r(10), c = r(1)("toStringTag"), u2 = ["NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList"], s2 = 0; s2 < 5; s2++) {
          var f = u2[s2], a = e[f], p = a && a.prototype;
          p && !p[c] && o(p, c, f), i[f] = i.Array;
        }
      }, function(t2, n2) {
        t2.exports = require("child_process");
      }, function(t2, n2) {
        t2.exports = require("crypto");
      }]);
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PathLinkerPlugin2,
  externalGroupPrefix: () => externalGroupPrefix,
  externalPrefix: () => externalPrefix
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  groups: []
};
async function chooseFolder() {
  let selectedPath = null;
  if (import_obsidian.Platform.isMobile) {
    try {
      const result2 = await window.Capacitor.Plugins.Filesystem.choose();
      return result2.path;
    } catch (e) {
      if (e.message !== "canceled")
        console.error(e);
      return null;
    }
  }
  const electron = require("electron");
  const result = await electron.remote.dialog.showOpenDialog({
    properties: ["openDirectory"]
  });
  if (result.canceled || result.filePaths.length === 0)
    return null;
  return result.filePaths[0];
}
var PathLinkerPluginSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.openedGroups = {};
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).addButton(
      (button) => button.setButtonText("Add new group").onClick(() => this.addNewGroup())
    );
    this.plugin.settings.groups.forEach((group, groupIndex) => {
      const groupContainer = containerEl.createDiv({ cls: "group-container" });
      const rightArrowSymbol = "\u23F5";
      const downArrowSymbol = "\u23F7";
      const groupHeader = groupContainer.createDiv({ cls: "group-header" });
      const groupTitle = groupHeader.createEl("span", { text: (this.openedGroups[groupIndex] ? downArrowSymbol : rightArrowSymbol) + group.name });
      new import_obsidian.Setting(groupHeader).addButton(
        (button) => button.setButtonText("Delete group").onClick(() => this.deleteGroup(groupIndex))
      );
      const devicesList = groupContainer.createDiv({ cls: "devices-list" });
      devicesList.classList.toggle("hiddenDevice", !this.openedGroups[groupIndex]);
      groupTitle.addEventListener("click", () => {
        this.openedGroups[groupIndex] = !this.openedGroups[groupIndex];
        devicesList.classList.toggle("hiddenDevice", !this.openedGroups[groupIndex]);
        groupTitle.textContent = (this.openedGroups[groupIndex] ? downArrowSymbol : rightArrowSymbol) + group.name;
      });
      new import_obsidian.Setting(devicesList).addText(
        (text) => text.setPlaceholder("Group name").setValue(group.name).onChange(async (value) => {
          group.name = value;
          await this.plugin.saveSettings();
          groupTitle.textContent = (this.openedGroups[groupIndex] ? downArrowSymbol : rightArrowSymbol) + group.name;
        })
      );
      group.devices.forEach((device, deviceIndex) => {
        const deviceEl = devicesList.createDiv({ cls: "device" });
        let pathTextComponent;
        let deviceSetting = new import_obsidian.Setting(deviceEl);
        deviceSetting.addText(
          (text) => text.setPlaceholder("Device name").setValue(device.name).onChange(async (value) => {
            device.name = value;
            await this.plugin.saveSettings();
          })
        ).addText(
          (text) => text.setPlaceholder("Device ID").setValue(device.id).onChange(async (value) => {
            device.id = value;
            await this.plugin.saveSettings();
          })
        ).addText((text) => {
          pathTextComponent = text;
          text.setPlaceholder("Device base path").setValue(device.basePath).onChange(async (value) => {
            device.basePath = value;
            await this.plugin.saveSettings();
          });
        });
        deviceSetting.addButton(
          (button) => button.setIcon("folder").setTooltip("Select folder").onClick(async () => {
            const selectedFolder = await chooseFolder();
            if (!selectedFolder)
              return;
            device.basePath = selectedFolder;
            pathTextComponent.setValue(device.basePath);
            await this.plugin.saveSettings();
          })
        );
        deviceSetting.addButton(
          (button) => button.setButtonText("Delete device").onClick(() => this.deleteDevice(groupIndex, deviceIndex))
        );
      });
      new import_obsidian.Setting(devicesList).addButton(
        (button) => button.setButtonText("Add device").onClick(() => this.addDeviceToGroup(groupIndex))
      );
    });
  }
  // Add a new group
  async addNewGroup() {
    const newGroup = {
      name: "New group",
      devices: []
    };
    this.plugin.settings.groups.push(newGroup);
    this.openedGroups[this.plugin.settings.groups.length - 1] = true;
    await this.plugin.saveSettings();
    this.display();
  }
  // Delete a group
  async deleteGroup(groupIndex) {
    this.plugin.settings.groups.splice(groupIndex, 1);
    await this.plugin.saveSettings();
    this.display();
  }
  // Add a new device to a group
  async addDeviceToGroup(groupIndex) {
    const group = this.plugin.settings.groups[groupIndex];
    const deviceName = "";
    const deviceBasePath = "";
    const newDevice = {
      name: deviceName,
      id: this.plugin.uuid,
      basePath: deviceBasePath
    };
    group.devices.push(newDevice);
    await this.plugin.saveSettings();
    this.display();
  }
  // Delete a device from a group
  async deleteDevice(groupIndex, deviceIndex) {
    this.plugin.settings.groups[groupIndex].devices.splice(deviceIndex, 1);
    await this.plugin.saveSettings();
    this.display();
  }
};

// src/main.ts
var path = __toESM(require("path"));
var fs2 = __toESM(require("fs"));

// src/nonembed.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");

// node_modules/@capacitor/filesystem/dist/esm/index.js
init_dist();

// node_modules/@capacitor/synapse/dist/synapse.mjs
function s(t) {
  t.CapacitorUtils.Synapse = new Proxy(
    {},
    {
      get(e, o) {
        return new Proxy({}, {
          get(w, r) {
            return (c, p, n) => {
              const i = t.Capacitor.Plugins[o];
              if (i === void 0) {
                n(new Error(`Capacitor plugin ${o} not found`));
                return;
              }
              if (typeof i[r] != "function") {
                n(new Error(`Method ${r} not found in Capacitor plugin ${o}`));
                return;
              }
              (async () => {
                try {
                  const a = await i[r](c);
                  p(a);
                } catch (a) {
                  n(a);
                }
              })();
            };
          }
        });
      }
    }
  );
}
function u(t) {
  t.CapacitorUtils.Synapse = new Proxy(
    {},
    {
      get(e, o) {
        return t.cordova.plugins[o];
      }
    }
  );
}
function y(t = false) {
  window.CapacitorUtils = window.CapacitorUtils || {}, window.Capacitor !== void 0 && !t ? s(window) : window.cordova !== void 0 && u(window);
}

// node_modules/@capacitor/filesystem/dist/esm/index.js
init_definitions();
var Filesystem = registerPlugin("Filesystem", {
  web: () => Promise.resolve().then(() => (init_web(), web_exports)).then((m) => new m.FilesystemWeb())
});
y();

// src/nonembed.ts
var import_obsidian2 = require("obsidian");
var fs = __toESM(require("fs"));
var import_electron = require("electron");
var HideTestWidget = class extends import_view.WidgetType {
  constructor(plugin, display, link) {
    super();
    this.plugin = plugin;
    this.display = display;
    this.link = link;
  }
  toDOM() {
    const span = document.createElement("span");
    span.textContent = this.display;
    span.className = "cm-link nonembed";
    isNonExistent(this.plugin, this.link).then((notExists) => {
      if (notExists) {
        span.classList.add("is-unresolved");
      }
    });
    span.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      generateOnClick(this.plugin, this.link)();
    };
    return span;
  }
};
function getHideTestPlugin(plugin) {
  return import_view.ViewPlugin.fromClass(
    class {
      constructor(view) {
        this.decorations = this.buildDecorations(view);
      }
      update(update) {
        if (update.docChanged || update.selectionSet || update.viewportChanged) {
          this.decorations = this.buildDecorations(update.view);
        }
      }
      buildDecorations(view) {
        const builder = new import_state.RangeSetBuilder();
        const regex = /\[\[([^\]]+?)\]\]/g;
        for (let { from, to } of view.visibleRanges) {
          const text = view.state.doc.sliceString(from, to);
          let match;
          while ((match = regex.exec(text)) !== null) {
            const full = match[0];
            const target = match[1];
            const trimmedTarget = target.trim();
            const hasExternalPrefix = trimmedTarget.startsWith(externalPrefix);
            const hasGroupPrefix = trimmedTarget.startsWith(externalGroupPrefix);
            if (!hasExternalPrefix && !hasGroupPrefix)
              continue;
            const displayText = getLinkDisplay(trimmedTarget);
            const link = getLinkPath(trimmedTarget);
            const start = from + match.index;
            const end = start + full.length;
            const cursorPos = view.state.selection.main.head;
            const cursorLine = view.state.doc.lineAt(cursorPos).number;
            const linkLine = view.state.doc.lineAt(start).number;
            const cursorNear = cursorLine === linkLine && cursorPos >= start - 1 && cursorPos <= end + 1;
            if (!cursorNear) {
              builder.add(
                start,
                end,
                import_view.Decoration.replace({ widget: new HideTestWidget(plugin, displayText, link) })
              );
            }
          }
        }
        return builder.finish();
      }
    },
    {
      decorations: (v) => v.decorations
    }
  );
}
function getNonEmbedReadModeHandler(plugin) {
  return (el) => {
    el.querySelectorAll("a.internal-link").forEach((link) => {
      const anchor = link;
      const dataHref = anchor.getAttribute("data-href") || "";
      const fileLink = getLinkPath(dataHref);
      let fileDisplay = getLinkDisplay(dataHref);
      if (dataHref !== anchor.innerText)
        fileDisplay = anchor.innerText;
      const isExternal = fileLink.startsWith(externalPrefix);
      const isGroup = fileLink.startsWith(externalGroupPrefix);
      if (isExternal || isGroup) {
        anchor.removeAttribute("data-href");
        anchor.removeAttribute("href");
        anchor.textContent = fileDisplay;
        anchor.classList.remove("is-unresolved");
        isNonExistent(plugin, fileLink).then((notExists) => {
          if (notExists) {
            anchor.classList.add("is-unresolved");
          }
        });
        anchor.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          generateOnClick(plugin, fileLink)();
        });
        anchor.classList.add("nonembed");
      }
    });
  };
}
function generateOnClick(plugin, linkpath) {
  return () => {
    const filePath = getFilePathFromLinkPath(plugin, linkpath);
    if (filePath === null) {
      return;
    }
    openInDefaultApp(plugin, filePath);
  };
}
async function isNonExistent(plugin, linkPath) {
  const externalStripped = linkPath.replace(externalPrefix, "");
  if (!plugin.isLocalFile(externalStripped)) {
    return false;
  }
  const filePath = getFilePathFromLinkPath(plugin, linkPath);
  if (filePath === null) {
    return true;
  }
  const fullPath = plugin.useVaultAsWorkingDirectory(filePath);
  if (import_obsidian2.Platform.isMobile) {
    const stat = await Filesystem.stat({ path: fullPath });
    return stat === null;
  }
  return !fs.existsSync(fullPath);
}
function getLinkDisplay(linkText) {
  if (linkText.includes("|")) {
    return linkText.split("|")[1];
  }
  const filePath = linkText.replace(externalPrefix, "").replace(externalGroupPrefix, "").trim();
  const fileName = filePath.split("/").pop();
  return fileName || filePath;
}
function getLinkPath(linkText) {
  linkText = linkText.split("|")[0];
  return linkText;
}
function getFilePathFromLinkPath(plugin, linkpath) {
  if (linkpath.startsWith(externalPrefix)) {
    return linkpath.replace(externalPrefix, "");
  }
  const fileData = linkpath.replace(externalGroupPrefix, "");
  const splitIndex = fileData.indexOf("/");
  const groupName = fileData.slice(0, splitIndex);
  let fileName = fileData.slice(splitIndex + 1);
  const [newName, newPath, isValid] = plugin.processLink(groupName, fileName);
  if (!isValid)
    return null;
  fileName = newPath;
  return fileName;
}
function openInDefaultApp(plugin, filePath) {
  filePath = plugin.useVaultAsWorkingDirectory(filePath);
  if (import_obsidian2.Platform.isMobile) {
    if (plugin.isLocalFile(filePath))
      plugin.app.vault.adapter.fs.open(filePath);
    else
      window.open(filePath);
  } else {
    import_electron.shell.openPath(filePath);
  }
}

// src/main.ts
var externalPrefix = "external:";
var externalGroupPrefix = "group:";
var _externalPrefix = "PathLinker:";
var FuzzyGroupFileSuggester = class extends import_obsidian3.FuzzySuggestModal {
  constructor(plugin, group = null, path2 = "", items = []) {
    super(plugin.app);
    this.group = null;
    this.path = "";
    this.items = [];
    this.plugin = plugin;
    this.group = group;
    this.path = path2;
    this.items = items;
    if (group === null)
      this.setPlaceholder("Select a group");
    else
      this.setPlaceholder("Select a path");
  }
  static async getItemsAsync(fullPath) {
    if (import_obsidian3.Platform.isMobile) {
      const result = await Filesystem.readdir({ path: fullPath });
      return result.files.map((file) => file.type === "directory" ? file.name + "/" : file.name);
    }
    const files = fs2.readdirSync(fullPath, { withFileTypes: true });
    return files.map((file) => file.isDirectory() ? file.name + "/" : file.name);
  }
  getItems() {
    if (this.group === null) {
      return this.plugin.settings.groups.map((group) => group.name);
    }
    this.items.sort((a, b) => {
      const aIsDir = a.endsWith("/");
      const bIsDir = b.endsWith("/");
      if (aIsDir !== bIsDir)
        return aIsDir ? -1 : 1;
      return a.localeCompare(b);
    });
    return this.items;
  }
  getItemText(item) {
    return item;
  }
  async onChooseItem(item) {
    var _a, _b;
    if (this.group !== null && !item.endsWith("/")) {
      const editor = (_a = this.plugin.app.workspace.activeEditor) == null ? void 0 : _a.editor;
      if (editor) {
        editor.replaceSelection("![[group:" + this.group + "/" + this.path + item + "]]");
      }
      return;
    }
    const groupName = this.group === null ? item : this.group;
    const group = this.plugin.settings.groups.find((group2) => group2.name === groupName);
    const devicePath = (_b = group == null ? void 0 : group.devices.find((device) => device.id === this.plugin.uuid)) == null ? void 0 : _b.basePath;
    if (devicePath === void 0) {
      new import_obsidian3.Notice(`You cannot use the group ${groupName} as this device does not have a base path selected.`, 3e3);
      return;
    }
    let newPath = "";
    if (this.group !== null)
      newPath = this.plugin.joinPaths([this.path, item]);
    const fullPath = this.plugin.joinPaths([devicePath, newPath]);
    if (newPath.startsWith("/"))
      newPath = newPath.slice(1);
    const newItems = await FuzzyGroupFileSuggester.getItemsAsync(fullPath);
    if (this.group === null) {
      new FuzzyGroupFileSuggester(this.plugin, item, "", newItems).open();
      return;
    }
    new FuzzyGroupFileSuggester(this.plugin, this.group, newPath, newItems).open();
    return;
  }
};
var PathLinkerPlugin2 = class extends import_obsidian3.Plugin {
  waitUntilPopulated(obj, property, callback) {
    const internalProperty = `_${property}`;
    Object.defineProperty(obj, property, {
      get() {
        return this[internalProperty];
      },
      set(value) {
        this[internalProperty] = value;
        if (value) {
          callback(value);
        }
      }
    });
  }
  getUUID() {
    if (!import_obsidian3.Platform.isMobile) {
      try {
        const { machineIdSync } = require_dist();
        return machineIdSync();
      } catch (error) {
        console.error("Failed to load node-machine-id", error);
        return "ERROR";
      }
    }
    let deviceId = localStorage.getItem("device-id");
    if (!deviceId) {
      deviceId = [...Array(64)].map(() => Math.floor(Math.random() * 16).toString(16)).join("");
      localStorage.setItem("device-id", deviceId);
    }
    return deviceId;
  }
  isLocalFile(filePath) {
    return !(filePath.startsWith("http://") || filePath.startsWith("https://"));
  }
  joinPaths(paths) {
    if (import_obsidian3.Platform.isMobile) {
      return paths.join("/").replace(/\/+/g, "/");
    } else {
      return path.join(...paths).replace(/\\/g, "/");
    }
  }
  isAbsolutePath(filePath) {
    if (import_obsidian3.Platform.isMobile) {
      return filePath.startsWith("/");
    } else {
      return path.isAbsolute(filePath);
    }
  }
  // If the path is relative, use the vault as the working directory
  // Otherwise, use the path without modification
  useVaultAsWorkingDirectory(filePath) {
    if (this.isAbsolutePath(filePath) || !this.isLocalFile(filePath)) {
      return filePath;
    } else {
      return this.joinPaths([this.app.vault.adapter.basePath, filePath]);
    }
  }
  basename(filePath) {
    if (import_obsidian3.Platform.isMobile) {
      const segments = filePath.split("/");
      return segments[segments.length - 1];
    } else {
      return path.basename(filePath, path.extname(filePath));
    }
  }
  extname(filePath) {
    if (import_obsidian3.Platform.isMobile) {
      const lastDotIndex = filePath.lastIndexOf(".");
      return lastDotIndex !== -1 ? filePath.slice(lastDotIndex) : "";
    } else {
      return path.extname(filePath);
    }
  }
  // Creates a TFile object for a file that doesn't exist
  // This is used for external links so that obisidan will try to read the file
  createFakeFile(linkpath) {
    let fileName;
    if (linkpath.startsWith(externalPrefix)) {
      fileName = linkpath.replace(externalPrefix, "");
    } else {
      const fileData = linkpath.replace(externalGroupPrefix, "");
      const splitIndex = fileData.indexOf("/");
      const groupName = fileData.slice(0, splitIndex);
      fileName = fileData.slice(splitIndex + 1);
      const [newName, newPath, isValid] = this.processLink(groupName, fileName);
      if (!isValid)
        return null;
      fileName = newPath;
    }
    if (!import_obsidian3.Platform.isMobile) {
      if (this.isLocalFile(fileName) && !fs2.existsSync(this.useVaultAsWorkingDirectory(fileName)))
        return null;
    }
    const basename2 = this.basename(fileName);
    const extension = this.extname(fileName).slice(1);
    const fileStats = {
      ctime: 0,
      mtime: 0,
      size: 0
    };
    const file = {
      path: _externalPrefix + fileName,
      // Path to the file (test.md)
      name: fileName,
      // File name with extension (test.md)
      extension,
      // File extension (md)
      basename: basename2,
      // Base name of the file (test)
      parent: null,
      // Root of the vault (not relevant here)
      stat: fileStats,
      // File stats (unused but required)
      vault: this.app.vault
      // Reference to the vault object
    };
    file.cache = function() {
      return {};
    };
    return file;
  }
  async onload() {
    await this.loadSettings();
    await this.saveSettings();
    this.addSettingTab(new PathLinkerPluginSettingTab(this.app, this));
    this.uuid = this.getUUID();
    this.addCommand({
      id: "select-group-file",
      name: "Select group file",
      callback: () => {
        new FuzzyGroupFileSuggester(this).open();
      }
    });
    this.registerMarkdownPostProcessor(getNonEmbedReadModeHandler(this));
    this.registerEditorExtension(getHideTestPlugin(this));
    this.oldCachedRead = this.app.vault.cachedRead;
    this.app.vault.cachedRead = async (file) => {
      if (file.path.startsWith(_externalPrefix)) {
        const filePath = this.useVaultAsWorkingDirectory(file.path.replace(_externalPrefix, ""));
        if (import_obsidian3.Platform.isMobile) {
          const result = await Filesystem.readFile({ path: filePath });
          if (result.data instanceof Blob) {
            const base64Data = await result.data.text();
            return base64Data;
          } else {
            const decodedContent = atob(result.data);
            return decodedContent;
          }
        } else {
          return fs2.readFileSync(filePath, "utf8");
        }
      }
      return this.oldCachedRead.call(this.app.vault, file);
    };
    this.originalGetResourcePath = this.app.vault.getResourcePath;
    this.app.vault.getResourcePath = (file) => {
      if (file.path.startsWith(_externalPrefix)) {
        let stripped = file.path.replace(_externalPrefix, "");
        const isTextFile = file.extension === "md" || file.extension === "canvas" || file.extension === "json" || file.extension === "txt";
        if (!isTextFile) {
          stripped = this.useVaultAsWorkingDirectory(stripped.replace("./", ""));
        }
        const isLocal = this.isLocalFile(stripped);
        const prefix = isLocal ? import_obsidian3.Platform.resourcePathPrefix : "";
        return prefix + stripped;
      }
      return this.originalGetResourcePath.call(this.app.vault, file);
    };
    this.originalGetFirstLinkpathDest = this.app.metadataCache.getFirstLinkpathDest;
    this.app.metadataCache.getFirstLinkpathDest = (linkpath, sourcePath) => {
      if (linkpath.startsWith(externalPrefix) || linkpath.startsWith(externalGroupPrefix)) {
        return this.createFakeFile(linkpath);
      }
      return this.originalGetFirstLinkpathDest.call(this.app.metadataCache, linkpath, sourcePath);
    };
    this.originalGetEmbedCreater = this.app.embedRegistry.getEmbedCreator;
    if (import_obsidian3.Platform.isMobile)
      this.app.embedRegistry.getEmbedCreator = (embedFile) => {
        const embedCreator = this.originalGetEmbedCreater.call(this.app.embedRegistry, embedFile);
        if (!embedCreator)
          return embedCreator;
        return (...embedData) => {
          const embed = embedCreator(...embedData);
          if (embedFile.extension != "pdf") {
            if (embedFile.extension == "md" || embedFile.extension == "canvas" || embedFile.extension == "json" || embedFile.extension == "txt") {
              return embed;
            }
            const observer = new MutationObserver(async () => {
              if (embed.containerEl.children[0]) {
                if (embed.containerEl.children[0].src.startsWith("file://")) {
                  let filePath = embed.containerEl.children[0].src;
                  filePath = filePath.replace(import_obsidian3.Platform.resourcePathPrefix, "");
                  filePath = filePath.split("#")[0];
                  const fileBase64 = (await Filesystem.readFile({ path: filePath })).data;
                  const dataType = this.app.viewRegistry.getTypeByExtension(embedFile.extension);
                  embed.containerEl.children[0].src = "data:" + dataType + "/" + embedFile.extension + ";base64," + fileBase64;
                }
                observer.disconnect();
              }
            });
            observer.observe(embed.containerEl, { childList: true });
            return embed;
          }
          this.waitUntilPopulated(embed.viewer, "child", (child) => {
            this.waitUntilPopulated(child, "pdfViewer", (pdfViewer) => {
              const originalOpen = pdfViewer.open;
              pdfViewer.open = async (openData) => {
                const isLocal = this.isLocalFile(openData.url);
                if (isLocal) {
                  const fileBase64 = await Filesystem.readFile({ path: openData.url });
                  openData.url = "data:application/pdf;base64," + fileBase64.data;
                }
                originalOpen.call(pdfViewer, openData);
              };
            });
          });
          return embed;
        };
      };
  }
  onunload() {
    this.app.vault.cachedRead = this.oldCachedRead;
    this.app.vault.getResourcePath = this.originalGetResourcePath;
    this.app.metadataCache.getFirstLinkpathDest = this.originalGetFirstLinkpathDest;
    this.app.embedRegistry.getEmbedCreator = this.originalGetEmbedCreater;
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  processLink(group, relativePath) {
    var _a;
    const devices = this.settings.groups.find((g) => g.name === group);
    if (!devices) {
      return ["(Invalid group)", "#", false];
    }
    const basePath = (_a = devices.devices.find((d) => d.id === this.uuid)) == null ? void 0 : _a.basePath;
    if (!basePath) {
      return ["(Invalid device)", "#", false];
    }
    const resolvedPath = `${basePath}/${relativePath}`;
    return ["", resolvedPath, true];
  }
};
/*! Bundled license information:

@capacitor/core/dist/index.js:
  (*! Capacitor: https://capacitorjs.com/ - MIT License *)
*/

/* nosourcemap */